[toc]

#### HTTP和HTTP 1.1区别

http1.1增加了以下功能

1. 支持长连接和流水线
   1. **Keep-Alive**和**close**请求头
   2. 一个TCP连接上可以传送多个HTTP请求和响应
2. 增加host字段
3. 增加了100状态码
4. 增加了cache新特性 



#### HTTP 中 GET与POST区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。
- GET调用1次，POST调用2次

oschina.net/news/77354/http-get-post-different



#### udp实现可靠连接

传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

- 1、添加seq/ack机制，确保数据发送到对端
- 2、添加发送和接收缓冲区，主要是用户超时重传。
- 3、添加超时重传机制。



#### 拥塞控制和流量控制的区别

##### 拥塞控制

​	拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法是：**（1）慢开始、拥塞避免（2）快重传、快恢复**。

##### 流量控制

​	流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。




#### TCP TIME_WAIT

##### 为什么要有TIME_WAIT?:

1、  网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；

2、  同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。

##### TIME_WAIT为什么保留的时间是两个MSL？

可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响。

在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！

##### 怎么处理

**1） 开启tw重用： net.ipv4.tcp_tw_reuse = 1**

**2） 开启tw回收： net.ipv4.tcp_tw_recycle = 1**



#### TCP粘包

TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾

##### 原因

**发送方**：

Nagle算法（主要作用：减少网络中报文段的数量）

1. 只有上一个分组得到确认，才会发送下一个分组
2. 收集多个小分组，在一个确认到来时一起发送

**接收方**

1. TCP将接收到的数据包保存在接收缓存里
2. 存速度大于取速度

##### 解决方法：

1. 发送方：关闭Nagle算法
2. 接收方：在应用层循环读取缓存内容



#### HTTP/2.0

##### 数据流、消息和帧

新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 HTTP/2 的三个概念:

- 数据流: 已建立的连接内的双向字节流，可以承载一条或多条消息。
- 消息: 与逻辑请求或响应消息对应的完整的一系列帧。
- 帧: HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。

这些概念的关系总结如下:

- 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。
- 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。
- 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。
- 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

##### 请求与响应复用

HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用: 客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。

##### 标头压缩

HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，利用霍夫曼编码，可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。



不加virtual的父类函数也可以重写，但不推荐
final不允许后面再重写
override必须是重写，且参数列表相同