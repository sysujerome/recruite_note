[toc]

### 应用层

#### HTTP和HTTP 1.1区别

http1.1增加了以下功能

1. 支持长连接和流水线
   1. **Keep-Alive**和**close**请求头
   2. 一个TCP连接上可以传送多个HTTP请求和响应
2. 增加host字段
3. 增加了100状态码
4. 增加了cache新特性 



#### HTTP 中 GET与POST区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。
- GET调用1次，POST调用2次

oschina.net/news/77354/http-get-post-different



#### HTTP/2.0

##### 数据流、消息和帧

新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。 为了说明这个过程，我们需要了解 HTTP/2 的三个概念:

- 数据流: 已建立的连接内的双向字节流，可以承载一条或多条消息。
- 消息: 与逻辑请求或响应消息对应的完整的一系列帧。
- 帧: HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。

这些概念的关系总结如下:

- 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。
- 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。
- 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。
- 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

##### 请求与响应复用

HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用: 客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来。

##### 标头压缩

HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，利用霍夫曼编码，可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。

不加virtual的父类函数也可以重写，但不推荐
final不允许后面再重写
override必须是重写，且参数列表相同



#### TLS

![](.\asserts\tls.png)

0 ms：TLS运行在TCP基础之上，这意味着我们必须首先完成TCP 三次握手“ ，这需要一个完整的来回交互(RTT)。

56 ms：TCP连接建立后，客户端发送一些协商信息，如TLS协议版本，支持的密码套件的列表，和其他TLS选项。

84 ms：服务器挑选TLS协议版本，在加密套件列表中挑选一个密码套件，附带自己的证书，并将响应返回给客户端。可选的，服务器也可以发送对客户端的证书认证请求和其他TLS扩展参数。

112 ms：假设双方协商好一个共同的TLS版本和加密算法，客户端使用服务器提供的证书，生成新的对称密钥，并用服务器的公钥进行加密，并告诉服务器切换到加密通信流程。到现在为止，所有被交换的数据都是以明文方式传输，除了对称密钥外，它采用的是服务器端的公钥加密。

140 ms：服务器用自己的私钥解密客户端发过来的对称密钥，并通过验证MAC检查消息的完整性，并返回给客户端一个加密的“Finished”的消息。

168 ms：客户端采用对称密钥解密消息，并验证MAC，如果一切OK，加密隧道就建立好了。应用程序数据就可以发送了。

##### 会话标识符

TLS握手只需要一个往返

“会话标识符”（RFC 5246）恢复机制在SSL 2.0中首次被引入，支持服务器端创建32字节的会话标识符，并将其作为“ServerHello”消息的一部分进行发送。在服务器内部，服务器保存一个会话ID和其对应的协商参数。对应地，客户端也同时存储会话ID信息，在后续的会话中，可以在“ClientHello”消息中携带session ID信息，告诉服务器客户端还记着session ID对应的密钥和加密算法等信息，并且可以重用这些信息。假设在客户端和服务器都能在它们各自的缓存中找到共享的会话ID参数，那么就可以缩减握手了，如下图所示。否则，开始一个新的会话协商，生成新的会话ID。

#### ca证书

ca证书里包含了证书内容，散列函数和加密密文。

生成：

![](.\asserts\ca证书-生成.webp)

验证：

![](.\asserts\ca证书.webp)

ca的公钥去解密密文，和证书内容哈希之后相比较验证。

有的证书内容是只包含公钥（服务器的公钥），如.crt、.cer、.pem
有的证书既包含公钥又包含私钥（服务器的私钥），如.pfx、.p12



#### 对称加密和非对称加密

**对称加密：**指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。 
常见的对称加密算法：DES，AES等。

**非对称加密：**指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。
最常用的非对称加密算法：RSA

**对称加密优缺点：**

对称加密相比非对称加密算法来说，加解密的**效率要高得多、加密速度快**。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。

**非对称加密优缺点：**

**安全性更高**，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。



#### udp实现可靠连接

传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

- 1、添加seq/ack机制，确保数据发送到对端
- 2、添加发送和接收缓冲区，主要是用户超时重传。
- 3、添加超时重传机制。



#### 拥塞控制和流量控制的区别

##### 拥塞控制

​	拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法是：**（1）慢开始、拥塞避免（2）快重传、快恢复**。

##### 流量控制

​	流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。




#### TCP TIME_WAIT

##### 为什么要有TIME_WAIT?:

1、  网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；

2、  同样网络情况不好并且无TIME_WAIT等待，关闭连接后无新连接，当接收到被动方重传或延迟的FIN包后，会给被动方回一个RST包，可能会影响被动方其它的服务连接。

##### TIME_WAIT为什么保留的时间是两个MSL？

可靠安全的关闭TCP连接。比如网络拥塞，主动方最后一个ACK被动方没收到，这时被动方会对FIN开启TCP重传，发送多个FIN包，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其它服务产生影响。

在一个连接没有进入CLOSED状态之前，这个连接是不能被重用的！

##### 怎么处理

**1） 开启tw重用： net.ipv4.tcp_tw_reuse = 1**

**2） 开启tw回收： net.ipv4.tcp_tw_recycle = 1**



#### TCP粘包

TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾

##### 原因

**发送方**：

Nagle算法（主要作用：减少网络中报文段的数量）

1. 只有上一个分组得到确认，才会发送下一个分组
2. 收集多个小分组，在一个确认到来时一起发送

**接收方**

1. TCP将接收到的数据包保存在接收缓存里
2. 存速度大于取速度

##### 解决方法：

1. 发送方：关闭Nagle算法
2. 接收方：在应用层循环读取缓存内容



