[toc]



#### 内联函数VS宏定义

内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。

在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。

**局限性：**函数中的执行代码不能太多，如果内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。



#### const 关键字

```c++
int* const num1;  // 指针本身不能变
const int* num2;  // 指针内容不能变
```

在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字说明的成员函数不能用来操作常对象。

const数据成员,只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。



#### static 关键字

  static的第一种含义：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。

  static的第二种含义：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。

  static的第三种含义：修饰函数时，表明该函数只在同一文件中调用。

  static的第四种含义：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归所有对象共有。

  static的第五种含义：修饰类成员函数，如上。

**注：** static修饰的函数没有指针，不能定义为virtual 或者 const

#### volatile 关键字

C/C++中的volatile关键字和const对应，用来修饰变量，用于告诉编译器该变量值是不稳定的，可能被更改。

在 C/C++ 中，对 `volatile` 对象的访问，有编译器优化上的副作用：

- 不允许被优化消失（optimized out）；
- 于序列上在另一个对 `volatile` 对象的访问之前。

**这里提及的「不允许被优化」表示对 `volatile` 变量的访问，编译器不能做任何假设和推理，都必须按部就班地与「内存」进行交互。**因此，上述例中「复用寄存器中的值」就是不允许的。

cpu为了提高流水线的运行效率，会做出比如：

1. 对无依赖的前后指令做适当的乱序和调度；

2. 对控制依赖的指令做分支预测；

3. 对读取内存等的耗时操作，做提前预读；

   等等。以上总总，都会导致指令乱序的可能。

从多核的视角上来说，是存在着乱序的可能的。比如，假设存在变量x = 0，cpu0上执行写入W0(x, 1)，对x写入1。接着在cpu1上，执行读取R1(x, 0)，得到x = 0，这在x86和arm/power的cpu上都是可能出现的。原因是x86上cpu核和cache以及内存之间，存在着store buffer，当W0(x, 1)执行成功后，修改只存在于store buffer中，并未写到cache以及内存上，因此cpu1读取不到最新的x值。对于arm/power来说，同样也有store buffer，而且还可能会有invalid queue，导致cpu1读不到最新的x值。

> 对于没有invalid queue的x86系列cpu来说，当修改从store buffer刷入cache时，就能够保证在其他核上能够读到最新的修改。但是，对于存在invalid queue的cpu来说，则不一定。

为了能够保证多核之间的修改的可见性，我们在写程序的时候需要加上内存屏障，例如x86上的mfence指令。

Intel为此提供三种内存屏障指令：

- sfence ，实现Store Barrior 会将store buffer中缓存的修改刷入L1 cache中，使得其他cpu核可以观察到这些修改，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见；
- lfence ，实现Load Barrior 会将invalidate queue失效，强制读取入L1 cache中，而且lfence之后的读操作不会被调度到之前，即lfence之前的读操作一定在lfence完成（并未规定全局可见性）；
- mfence ，实现Full Barrior 同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作结果全局可见；
- lock 用来修饰当前指令操作的内存只能由当前CPU使用，若指令不操作内存仍然由用，因为这个修饰会让指令操作本身原子化，而且自带Full Barrior效果；还有指令比如IO操作的指令、exch等原子交换的指令，任何带有lock前缀的指令以及CPUID等指令都有内存屏障的作用。



https://blog.csdn.net/fengbingchun/article/details/104109696



#### 指针常量与常量指针的区别

**指针常量就是指针本身是常量**，换句话说，就是指针里面所存储的内容（内存地址）是常量，不能改变。但是，内存地址所对应的内容是可以通过指针改变的。

**常量指针就是指向常量的指针**，换句话说，就是指针指向的是常量，它指向的内容不能发生改变，不能通过指针来修改它指向的内容。但是，指针自身不是常量，它自身的值可以改变，从而指向另一个常量。



#### delete详解

首先调用析构函数，完成类成员的释放，比如类成员有vector也指向了堆上的内存，就需要在析构函数中同样使用delete释放这块内存，或者说它自身处于一个容器当中，就需要在这个容器中erase它

然后再free掉整个对象的内存；

delete b过后，b仍然指向改内存，即地址不变，但指针可能为悬垂指针，访问它可能带来意想不到的结果，也可能正确访问，不确定，所以建议delete后，把指针设置成NULL，后面也可根据指针是否为NULL判断是否可用

https://blog.csdn.net/sumx2015/article/details/80232825



#### 虚函数的实现原理

有个隐藏成员指向虚表，定义为虚函数的函数指针会放到虚表上，然后在虚表上遍历寻找。重写的话，就覆盖基类函数地址。

https://www.cnblogs.com/malecrab/p/5572730.html

对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。
原文链接：https://blog.csdn.net/haoel/article/details/1948051



#### 内存对齐主要遵循下面四个原则:

1. 结构体变量的**起始地址**能够被其最宽的成员大小整除

2. 结构体每个成员相对于**起始地址的偏移**能够被其**自身大小整除**，如果不能则在**前一个成员后面**补充字节

3. 结构体总体大小能够**被最宽的成员的大小**整除，如不能则在**后面**补充字节

4. 编译器在编译的时候是可以指定对齐大小的，实际使用的有效对齐其实是取指定大小和自身大小的最小值，一般默认的对齐大小是4。

   链接：https://www.zhihu.com/question/27862634/answer/208895189



#### 必须在构造函数初始化列表里进行初始化的数据成员

**1，常量成员**

常量成员只能初始化不能赋值，所以必须放在初始化列表里。

**2，引用类型**

引用必须在定义时初始化，并且不能重新赋值，所以必须放在初始化表里。

**3，对象成员**

这个成员是其他类的对象，例如上面的Address  addr成员。如果把它放在构造函数的初始化列表里，此时会调用Address类的copy constructor函数，对这个类对象进行初始化。如果把它放在构造函数体中，会先调用Address类的default constructor函数，然后再调用Address类的copy constructor函数。从性能上考虑，把对象成员的初始化放在初始化列表里性能会更高。



#### cast

##### const_cast

将const类型转化为非const类型

##### static_cast

提供除了const转化之外的所有cast转化功能，特别是在较大算术类型赋值给较小类型时不会产生警告。

##### reinterpret_cast

为运算对象的位模式提供较低层次上的重新解释，即按照底层数据来直接转换。在数字转字符串时会有风险。

##### dynamic_cast

dynamic 本身只能用于存在虚函数的父子关系的强制类型转换



#### override、final、纯虚函数

两者都是放在函数申明后面

override：派生类该函数一定要重写，否则编译不过

final：派生类不允许重写该函数，否则编译失败

纯虚函数：函数声明后面加上=0，派生类必须重写该函数



#### 内联函数VS宏定义

内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。



#### c++ stl 内存池管理技术

第一级配置器
第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。

第二级配置器
在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。
    如果要分配的区块大于128bytes，则移交给第一级配置器处理。
    如果要分配的区块小于128bytes，则以 内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。
原文链接：https://blog.csdn.net/a987073381/article/details/52245795



#### vector扩容

c++标准里没有规定扩容因子，由编译器设定









